import copy
import pathlib
import shutil
import textwrap
import time
import urllib.parse
from typing import Generator

import yaml
from python_on_whales import docker

from dagster import (
    AssetExecutionContext,
    AssetIn,
    AssetKey,
    AssetMaterialization,
    MaterializeResult,
    MetadataValue,
    Output,
    asset,
    AssetsDefinition,
)
from OpenStudioLandscapes.engine.base.assets import KEY as KEY_BASE
from OpenStudioLandscapes.engine.constants import *
from OpenStudioLandscapes.engine.utils import *
from OpenStudioLandscapes.engine.base.ops import op_docker_compose_graph
from OpenStudioLandscapes.engine.base.ops import op_group_out

from OpenStudioLandscapes.Kitsu.constants import *


@asset(
    **ASSET_HEADER,
    ins={
        "group_in": AssetIn(
            AssetKey([*KEY_BASE, "group_out"])
        ),
    },
)
def env(
    context: AssetExecutionContext,
    group_in: dict,  # pylint: disable=redefined-outer-name
) -> Generator[Output[dict] | AssetMaterialization, None, None]:

    env_in = copy.deepcopy(group_in["env"])

    # expanding variables in OpenStudioLandscapes.Kitsu.constants.ENVIRONMENT
    for k, v in ENVIRONMENT.items():
        if isinstance(v, str):
            ENVIRONMENT[k] = v.format(**env_in)

    env_in.update(ENVIRONMENT)

    yield Output(env_in)

    yield AssetMaterialization(
        asset_key=context.asset_key,
        metadata={
            "__".join(context.asset_key.path): MetadataValue.json(env_in),
            "ENVIRONMENT": MetadataValue.json(ENVIRONMENT),
        },
    )


@asset(
    **ASSET_HEADER,
)
def apt_packages(
    context: AssetExecutionContext,
) -> Generator[Output[dict[str, list[str]]] | AssetMaterialization, None, None]:
    """ """

    _apt_packages = dict()

    _apt_packages["base"] = [
        "sudo",
        "htop",
        "curl",
    ]

    yield Output(_apt_packages)

    yield AssetMaterialization(
        asset_key=context.asset_key,
        metadata={
            "__".join(context.asset_key.path): MetadataValue.json(_apt_packages),
        },
    )


@asset(
    **ASSET_HEADER,
    ins={
        "env": AssetIn(
            AssetKey([*KEY, "env"]),
        ),
        "apt_packages": AssetIn(
            AssetKey([*KEY, "apt_packages"]),
        ),
        "script_zou_launcher": AssetIn(
            AssetKey([*KEY, "script_zou_launcher"]),
        ),
        "script_init_db": AssetIn(
            AssetKey([*KEY, "script_init_db"]),
        ),
    },
)
def build_docker_image(
    context: AssetExecutionContext,
    env: dict,  # pylint: disable=redefined-outer-name
    apt_packages: dict[str, list[str]],  # pylint: disable=redefined-outer-name
    script_zou_launcher: pathlib.Path,  # pylint: disable=redefined-outer-name
    script_init_db: pathlib.Path,  # pylint: disable=redefined-outer-name
) -> Generator[Output[str] | AssetMaterialization, None, None]:
    """ """

    docker_file = pathlib.Path(
        env["DOT_LANDSCAPES"],
        env.get("LANDSCAPE", "default"),
        f"{GROUP}__{'__'.join(KEY)}",
        "__".join(context.asset_key.path),
        "Dockerfiles",
        "Dockerfile",
    )

    shutil.rmtree(docker_file.parent, ignore_errors=True)
    docker_file.parent.mkdir(parents=True, exist_ok=True)

    tags = [
        f"{env.get('IMAGE_PREFIX')}/{'__'.join(context.asset_key.path).lower()}:latest",
        f"{env.get('IMAGE_PREFIX')}/{'__'.join(context.asset_key.path).lower()}:{env.get('LANDSCAPE', str(time.time()))}",
    ]

    apt_install_str_base: str = get_apt_install_str(
        apt_install_packages=apt_packages["base"],
    )

    script_init_db_dir = docker_file.parent / "scripts"
    script_init_db_dir.mkdir(parents=True, exist_ok=True)

    for script in [
        script_zou_launcher,
        script_init_db,
    ]:

        shutil.copy(
            src=script,
            dst=script_init_db_dir,
        )

    # @formatter:off
    docker_file_str = textwrap.dedent(
        """
        # {auto_generated}
        # {dagster_url}
        # https://hub.docker.com/r/cgwire/cgwire
        FROM cgwire/cgwire:latest AS {image_name}
        LABEL authors="{AUTHOR}"

        SHELL ["/bin/bash", "-c"]

        ARG DEBIAN_FRONTEND=noninteractive

        ENV CONTAINER_TIMEZONE={TIMEZONE}
        ENV SET_CONTAINER_TIMEZONE=true
        
        ENV DB_ADMIN={KITSU_ADMIN_USER}
        ENV DB_PASSWORD={KITSU_DB_PASSWORD}
        ENV PGPORT={KITSU_PGPORT}
        ENV SECRET_KEY={KITSU_SECRET_KEY}
        ENV PREVIEW_FOLDER={KITSU_PREVIEW_FOLDER}
        ENV TMP_DIR={KITSU_TMP_DIR}

        RUN apt-get update && apt-get upgrade -y

        {apt_install_str_base}

        RUN apt-get clean
        
        WORKDIR /opt/zou

        COPY --chmod=0755 ./scripts/zou_launcher.sh .
        COPY --chmod=0755 ./scripts/init_db.sh .

        ENTRYPOINT []
    """
    ).format(
        apt_install_str_base=apt_install_str_base,
        auto_generated=f"AUTO-GENERATED by Dagster Asset {'__'.join(context.asset_key.path)}",
        dagster_url=urllib.parse.quote(
            f"http://localhost:3000/asset-groups/{'%2F'.join(context.asset_key.path)}",
            safe=":/%",
        ),
        image_name="__".join(context.asset_key.path).lower(),
        **env,
    )
    # @formatter:on

    # Todo
    #  - [ ] WARN: StageNameCasing: Stage name 'Kitsu__build' should be lowercase (line 5)

    with open(docker_file, "w") as fw:
        fw.write(docker_file_str)

    with open(docker_file, "r") as fr:
        docker_file_content = fr.read()

    stream = docker.build(
        context_path=docker_file.parent.as_posix(),
        cache=DOCKER_USE_CACHE,
        tags=tags,
        stream_logs=True,
    )

    log: str = ""

    for msg in stream:
        context.log.debug(msg)
        log += msg

    cmds_docker = compile_cmds(
        docker_file=docker_file,
        tag=tags[1],
    )

    yield Output(tags[1])

    yield AssetMaterialization(
        asset_key=context.asset_key,
        metadata={
            "__".join(context.asset_key.path): MetadataValue.path(tags[1]),
            "docker_file": MetadataValue.md(f"```shell\n{docker_file_content}\n```"),
            **cmds_docker,
            "build_logs": MetadataValue.md(f"```shell\n{log}\n```"),
            "env": MetadataValue.json(env),
        },
    )


@asset(
    **ASSET_HEADER,
    ins={
        "env": AssetIn(
            AssetKey([*KEY, "env"]),
        ),
    },
    description="",
)
def script_init_db(
    context: AssetExecutionContext,
    env: dict,  # pylint: disable=redefined-outer-name
) -> Generator[Output[pathlib.Path] | AssetMaterialization, None, None]:
    """ """

    init_db = dict()

    init_db["exe"] = shutil.which("bash")
    init_db["script"] = str()

    # Source:
    # /opt/zou/init_zou.sh
    kitsu_admin_user = env.get("KITSU_ADMIN_USER", "admin@example.com")
    kitsu_admin_password = env.get("KITSU_DB_PASSWORD", "mysecretpassword")
    kitsu_pgport = env.get("KITSU_PGPORT", "5432")
    kitsu_secret_key = env.get("SECRET_KEY", "yourrandomsecretkey")
    kitsu_preview_folder = env.get("KITSU_PREVIEW_FOLDER", "/opt/zou/previews")
    kitsu_tmp_dir = env.get("KITSU_TMP_DIR", "/opt/zou/tmp")

    # https://github.com/michimussato/kitsu-setup/blob/main/README_KITSU.md
    init_db["script"] += "#!/bin/bash\n"
    init_db["script"] += "export LC_ALL=C.UTF-8\n"
    init_db["script"] += "export LANG=C.UTF-8\n"
    init_db["script"] += "\n"
    init_db["script"] += "# https://zou.cg-wire.com/\n"
    init_db["script"] += f"export KITSU_ADMIN={kitsu_admin_user}\n"
    init_db["script"] += f"export DB_PASSWORD={kitsu_admin_password}\n"
    init_db["script"] += f"export PGPORT={kitsu_pgport}\n"
    init_db["script"] += f"export SECRET_KEY={kitsu_secret_key}\n"
    init_db["script"] += f"export PREVIEW_FOLDER={kitsu_preview_folder}\n"
    init_db["script"] += f"export TMP_DIR={kitsu_tmp_dir}\n"
    init_db["script"] += "\n"
    init_db["script"] += "# Default encoding without specifying it is SQL_ASCII\n"
    init_db["script"] += "# psql zoudb -c 'SHOW SERVER_ENCODING'\n"
    init_db["script"] += "su - postgres -c '/usr/lib/postgresql/14/bin/initdb --pgdata=/var/lib/postgresql/14/main --auth=trust --encoding=UTF8'\n"
    init_db["script"] += "\n"
    init_db["script"] += "service postgresql start\n"
    init_db["script"] += "service redis-server start\n"
    init_db["script"] += "\n"
    init_db["script"] += "sudo -u postgres psql -U postgres -c 'create user root;'\n"
    init_db["script"] += "sudo -u postgres psql -U postgres -c 'create database zoudb;'\n"
    init_db["script"] += "sudo -u postgres psql -U postgres -d postgres -c \"alter user postgres with password '${DB_PASSWORD}';\"\n"
    init_db["script"] += "\n"
    init_db["script"] += "source /opt/zou/env/bin/activate\n"
    # init_db["script"] += "source /etc/zou/zou.env\n"
    init_db["script"] += "\n"
    init_db["script"] += "zou init-db\n"
    init_db["script"] += "zou init-data\n"
    init_db["script"] += "\n"
    init_db["script"] += "mkdir -p ${TMP_DIR}\n"
    init_db["script"] += "chown -R postgres:postgres ${TMP_DIR}\n"
    init_db["script"] += "\n"
    init_db["script"] += "zou create-admin ${KITSU_ADMIN} --password ${DB_PASSWORD}\n"
    init_db["script"] += "\n"
    init_db["script"] += "service postgresql stop\n"
    init_db["script"] += "service redis-server stop\n"
    # init_db["script"] += "sleep 3\n"
    init_db["script"] += "\n"
    init_db["script"] += "# service redis-server is down but process seems to persist\n"
    init_db["script"] += "# for some reason\n"
    init_db["script"] += "pkill redis\n"
    # init_db["script"] += "sleep 3\n"
    init_db["script"] += "\n"
    init_db["script"] += "exit 0\n"

    init_db_script = pathlib.Path(
        env["DOT_LANDSCAPES"],
        env.get("LANDSCAPE", "default"),
        f"{GROUP}__{'__'.join(KEY)}",
        "__".join(context.asset_key.path),
        "init_db.sh",
    )

    init_db_script.parent.mkdir(parents=True, exist_ok=True)

    with open(
        file=init_db_script,
        mode="w",
    ) as sh_init_zou:
        sh_init_zou.write(init_db["script"])

    yield Output(init_db_script)

    yield AssetMaterialization(
        asset_key=context.asset_key,
        metadata={
            "__".join(context.asset_key.path): MetadataValue.path(init_db_script),
            "dict_init_db": MetadataValue.json(init_db),
            "script_init_db": MetadataValue.md(f"```shell\n{init_db['script']}\n```"),
        },
    )


@asset(
    **ASSET_HEADER,
    ins={
        "env": AssetIn(
            AssetKey([*KEY, "env"]),
        ),
    },
    description="",
)
def script_zou_launcher(
    context: AssetExecutionContext,
    env: dict,  # pylint: disable=redefined-outer-name
) -> Generator[Output[pathlib.Path] | AssetMaterialization, None, None]:
    """ """

    script_dict = dict()

    script_dict["exe"] = shutil.which("bash")
    script_dict["script"] = str()

    kitsu_admin_user = env.get("KITSU_ADMIN_USER", "admin@example.com")
    kitsu_admin_password = env.get("KITSU_DB_PASSWORD", "mysecretpassword")
    kitsu_pgport = env.get("KITSU_PGPORT", "5432")
    kitsu_secret_key = env.get("SECRET_KEY", "yourrandomsecretkey")
    kitsu_preview_folder = env.get("KITSU_PREVIEW_FOLDER", "/opt/zou/previews")
    kitsu_tmp_dir = env.get("KITSU_TMP_DIR", "/opt/zou/tmp")

    # https://github.com/michimussato/kitsu-setup/blob/main/README_KITSU.md
    script_dict["script"] += f"#!{script_dict['exe']}\n"
    script_dict["script"] += "export LC_ALL=C.UTF-8\n"
    script_dict["script"] += "export LANG=C.UTF-8\n"
    script_dict["script"] += "\n"
    script_dict["script"] += "# https://zou.cg-wire.com/\n"
    script_dict["script"] += f"export KITSU_ADMIN={kitsu_admin_user}\n"
    script_dict["script"] += f"export DB_PASSWORD={kitsu_admin_password}\n"
    script_dict["script"] += f"export PGPORT={kitsu_pgport}\n"
    script_dict["script"] += f"export SECRET_KEY={kitsu_secret_key}\n"
    script_dict["script"] += f"export PREVIEW_FOLDER={kitsu_preview_folder}\n"
    script_dict["script"] += f"export TMP_DIR={kitsu_tmp_dir}\n"
    script_dict["script"] += "\n"
    script_dict["script"] += "if [[ -d /var/lib/postgresql/14/main && -z \"$( ls -A '/var/lib/postgresql/14/main')\" ]]; then\n"
    script_dict["script"] += "    echo /var/lib/postgresql/14/main empty\n"
    script_dict["script"] += "    echo Initializing...\n"
    script_dict["script"] += "    bash init_db.sh\n"
    script_dict["script"] += "elif [[ ! -d /var/lib/postgresql/14/main ]]; then\n"
    script_dict["script"] += "    echo /var/lib/postgresql/14/main not found\n"
    script_dict["script"] += "    echo Initializing...\n"
    script_dict["script"] += "    bash init_db.sh\n"
    script_dict["script"] += "fi;\n"
    script_dict["script"] += "\n"
    script_dict["script"] += "bash start_zou.sh &\n"
    # script_dict["script"] += "bash start_zou.sh\n"
    script_dict["script"] += "\n"
    script_dict["script"] += "exit 0\n"

    zou_launcher_script = pathlib.Path(
        env["DOT_LANDSCAPES"],
        env.get("LANDSCAPE", "default"),
        f"{GROUP}__{'__'.join(KEY)}",
        "__".join(context.asset_key.path),
        "zou_launcher.sh",
    )

    zou_launcher_script.parent.mkdir(parents=True, exist_ok=True)

    with open(
        file=zou_launcher_script,
        mode="w",
    ) as sh_init_zou:
        sh_init_zou.write(script_dict["script"])

    yield Output(zou_launcher_script)

    yield AssetMaterialization(
        asset_key=context.asset_key,
        metadata={
            "__".join(context.asset_key.path): MetadataValue.path(zou_launcher_script),
            "dict_zou_launcher": MetadataValue.json(script_dict),
            "script_zou_launcher": MetadataValue.md(f"```shell\n{script_dict['script']}\n```"),
        },
    )


@asset(
    **ASSET_HEADER,
    ins={
        "env": AssetIn(
            AssetKey([*KEY, "env"]),
        ),
        "build": AssetIn(
            AssetKey([*KEY, "build_docker_image"]),
        ),
    },
)
def compose(
    context: AssetExecutionContext,
    env: dict,  # pylint: disable=redefined-outer-name
    build: str,  # pylint: disable=redefined-outer-name
) -> Generator[Output[dict] | AssetMaterialization, None, None]:
    """ """

    cmd_docker_run = [
        shutil.which("docker"),
        "run",
        "--rm",
        "--interactive",
        "--tty",
        build,
        "/bin/bash",
    ]

    volumes = [
        f"{env.get('NFS_ENTRY_POINT')}:{env.get('NFS_ENTRY_POINT')}",
        f"{env.get('NFS_ENTRY_POINT')}:{env.get('NFS_ENTRY_POINT_LNS')}",
    ]

    if not KITSUDB_INSIDE_CONTAINER:

        kitsu_db_dir_host = (
            pathlib.Path(env.get("KITSU_DATABASE_INSTALL_DESTINATION"))
            / "postgresql"
            / "14"
            / "main"
        )
        kitsu_db_dir_host.mkdir(parents=True, exist_ok=True)

        volumes.insert(
            0,
            f"{kitsu_db_dir_host.as_posix()}:/var/lib/postgresql/14/main",
        )

        kitsu_previews_host = (
            pathlib.Path(env.get("KITSU_DATABASE_INSTALL_DESTINATION")) / "previews"
        )
        kitsu_previews_host.mkdir(parents=True, exist_ok=True)

        volumes.insert(
            1,
            f"{kitsu_previews_host}:/opt/zou/previews",
        )

    docker_dict = {
        "services": {
            "kitsu": {
                "container_name": "kitsu",
                "hostname": "kitsu",
                "domainname": env.get("ROOT_DOMAIN"),
                "restart": "always",
                "image": build,
                "volumes": volumes,
                # "healthcheck": {
                #     # Todo:
                #     #  - [ ] fix: test succeeds even if Postgres is down
                #     #  "test": ["CMD-SHELL", "psql -U ${DB_USER} -d ${DB_MAIN} -c 'SELECT 1' || exit 1"],
                #     "test": ["CMD", "curl", "-f", f"http://localhost:{env.get('KITSU_PORT_CONTAINER')}"],
                #     "interval": "10s",
                #     "timeout": "2s",
                #     "retries": "3",
                # },
                "command": [
                    "bash",
                    # "/opt/zou/start_zou.sh",
                    "/opt/zou/zou_launcher.sh",
                ],
                "ports": [
                    f"{env.get('KITSU_PORT_HOST')}:{env.get('KITSU_PORT_CONTAINER')}",
                ],
            },
        },
    }

    docker_yaml = yaml.dump(docker_dict)

    yield Output(docker_dict)

    yield AssetMaterialization(
        asset_key=context.asset_key,
        metadata={
            "__".join(context.asset_key.path): MetadataValue.json(docker_dict),
            "docker_yaml": MetadataValue.md(f"```yaml\n{docker_yaml}\n```"),
            "cmd_docker_run": MetadataValue.path(cmd_list_to_str(cmd_docker_run)),
        },
    )


group_out = AssetsDefinition.from_op(
    op_group_out,
    group_name=GROUP,
    tags_by_output_name={
        "group_out": {
            "group_out": "third_party",
        },
    },
    key_prefix=KEY,
    keys_by_input_name={
        "compose": AssetKey(
            [*KEY, "compose"]
        ),
        "env": AssetKey(
            [*KEY, "env"]
        ),
    },
)


docker_compose_graph = AssetsDefinition.from_op(
    op_docker_compose_graph,
    group_name=GROUP,
    key_prefix=KEY,
    keys_by_input_name={
        "group_out": AssetKey(
            [*KEY, "group_out"]
        ),
    },
)
